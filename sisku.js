const cmaxes =
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */
  (function () {
    'use strict'

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child
      }
      ctor.prototype = parent.prototype
      child.prototype = new ctor()
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message
      this.expected = expected
      this.found = found
      this.location = location
      this.name = 'SyntaxError'

      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, peg$SyntaxError)
      }
    }

    peg$subclass(peg$SyntaxError, Error)

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return '"' + literalEscape(expectation.text) + '"'
        },

        class: function (expectation) {
          var escapedParts = '',
            i

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts +=
              expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) +
                  '-' +
                  classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i])
          }

          return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'
        },

        any: function (expectation) {
          return 'any character'
        },

        end: function (expectation) {
          return 'end of input'
        },

        other: function (expectation) {
          return expectation.description
        },
      }

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase()
      }

      function literalEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function classEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/\]/g, '\\]')
          .replace(/\^/g, '\\^')
          .replace(/-/g, '\\-')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
          i,
          j

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i])
        }

        descriptions.sort()

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i]
              j++
            }
          }
          descriptions.length = j
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0]

          case 2:
            return descriptions[0] + ' or ' + descriptions[1]

          default:
            return (
              descriptions.slice(0, -1).join(', ') +
              ', or ' +
              descriptions[descriptions.length - 1]
            )
        }
      }

      function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : 'end of input'
      }

      return (
        'Expected ' +
        describeExpected(expected) +
        ' but ' +
        describeFound(found) +
        ' found.'
      )
    }

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {}

      var peg$FAILED = {},
        peg$startRuleIndices = { text: 0 },
        peg$startRuleIndex = 0,
        peg$consts = [
          function (expr) {
            return _node_int(expr)
          },
          function (expr) {
            return expr
          },
          function (expr) {
            return ['cmavo', _join(expr)]
          },
          function (expr) {
            return ['gismu', _join(expr)]
          },
          function (expr) {
            return ['lujvo', _join(expr)]
          },
          function (expr) {
            return ["fu'ivla", _join(expr)]
          },
          function (expr) {
            return ['cmevla', _join(expr)]
          },
          function (expr) {
            return [_join(expr), '-']
          },
          function (expr) {
            return [_join(expr)]
          },
          function (expi, exp) {
            return [_join(expi), '-', _join(exp)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          /^[a]/,
          peg$classExpectation(['a'], false, false),
          /^[aeo]/,
          peg$classExpectation(['a', 'e', 'o'], false, false),
          /^[aeiou]/,
          peg$classExpectation(['a', 'e', 'i', 'o', 'u'], false, false),
          /^[i]/,
          peg$classExpectation(['i'], false, false),
          /^[u]/,
          peg$classExpectation(['u'], false, false),
          /^[y]/,
          peg$classExpectation(['y'], false, false),
          /^[i\u0269]/,
          peg$classExpectation(['i', '\u0269'], false, false),
          /^[uw]/,
          peg$classExpectation(['u', 'w'], false, false),
          function () {
            return ['u', '']
          },
          /^[l]/,
          peg$classExpectation(['l'], false, false),
          /^[m]/,
          peg$classExpectation(['m'], false, false),
          /^[n]/,
          peg$classExpectation(['n'], false, false),
          /^[r]/,
          peg$classExpectation(['r'], false, false),
          /^[pfbgvkx]/,
          peg$classExpectation(
            ['p', 'f', 'b', 'g', 'v', 'k', 'x'],
            false,
            false
          ),
          /^[d]/,
          peg$classExpectation(['d'], false, false),
          /^[jz]/,
          peg$classExpectation(['j', 'z'], false, false),
          /^[cs]/,
          peg$classExpectation(['c', 's'], false, false),
          /^[x]/,
          peg$classExpectation(['x'], false, false),
          /^[t]/,
          peg$classExpectation(['t'], false, false),
          /^[,']/,
          peg$classExpectation([',', "'"], false, false),
          /^[}]/,
          peg$classExpectation(['}'], false, false),
          peg$anyExpectation(),
          /^[^a-za-z,']/,
          peg$classExpectation([['a', 'z'], ['a', 'z'], ',', "'"], true, false),
          function (expr) {
            return ['drata', _join(expr)]
          },
          /^[^ ]/,
          peg$classExpectation([' '], true, false),
        ],
        peg$bytecode = [
          peg$decode("%$;!0#*;!&/' 8!: !! )"),
          peg$decode('%;"/\' 8!:!!! )'),
          peg$decode(
            ";_.\xEE &;#.\xE8 &%;'/' 8!:\"!! ).\xD6 &%;$/' 8!:#!! ).\xC4 &%%%<;$=.##&&!&'#/\x90#%<;&=.##&&!&'#/{$%<;'=.##&&!&'#/f$%<%;6/>#;\\/5$;K/,$;D/#$+$)($'#(#'#(\"'#&'#=.##&&!&'#/,$;(/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:$!! )./ &%;&/' 8!:%!! )"
          ),
          peg$decode(
            "%%%<;,=/##&'!&&#/N#$;@/&#0#*;@&&&#/8$%<;^=/##&'!&&#/#$+#)(#'#(\"'#&'#.# &;,/' 8!:&!! )"
          ),
          peg$decode(
            "%;</k#%<;?=/##&'!&&#/V$%<;>=/##&'!&&#/A$;H/8$%<;]=/##&'!&&#/#$+%)(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%;+/Q#;A/H$%<;?=/##&'!&&#/3$$;B0#*;B&/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode('%;%/,#;>/#$+")("\'#&\'#'),
          peg$decode(
            "%%<;#=.##&&!&'#/\u0172#%<%;4/X#%<;?=.##&&!&'#/C$;K/:$;\\.\" &\"/,$;(/#$+%)(%'#($'#(#'#(\"'#&'#.T &%;4/J#%<;?=/##&'!&&#/5$;K/,$;:/#$+$)($'#(#'#(\"'#&'#=.##&&!&'#/\xE7$%%<;\\=.##&&!&'#/\xA0#%<%;P/9#$;P/&#0#*;P&&&#/#$+\")(\"'#&'#=.##&&!&'#/k$;D/b$$%;E/,#;\\/#$+\")(\"'#&'#06*%;E/,#;\\/#$+\")(\"'#&'#&/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#.0 &$;K/&#0#*;K&&&#/8$%<;]=/##&'!&&#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%$%;3.c &;..] &;0.W &%%<;)=.##&&!&'#/A#;1/8$%<;)=.##&&!&'#/#$+#)(#'#(\"'#&'#/' 8!:'!! )0u*%;3.c &;..] &;0.W &%%<;)=.##&&!&'#/A#;1/8$%<;)=.##&&!&'#/#$+#)(#'#(\"'#&'#/' 8!:'!! )&/\x8E#%;&.# &;9/' 8!:(!! ).m &%;2.N &;-.H &;/.B &%;7/8#%<;?=/##&'!&&#/#$+\")(\"'#&'#/2#;:/)$8\":)\"\"! )(\"'#&'#/#$+\")(\"'#&'#"
          ),
          peg$decode(';&.) &;..# &;-'),
          peg$decode(
            "%$;10#*;1&/\xE2#;9.\xD3 &%;7/V#%<;?=/##&'!&&#/A$%<;K=.##&&!&'#/,$;:/#$+$)($'#(#'#(\"'#&'#.\x90 &;0.\x8A &;/.\x84 &%%;7/M#%<;?=/##&'!&&#/8$%<;K=.##&&!&'#/#$+#)(#'#(\"'#&'#.\" &\"/5#;N/,$;K/#$+#)(#'#(\"'#&'#.) &;3.# &;2/#$+\")(\"'#&'#"
          ),
          peg$decode(
            "%%<;*=.##&&!&'#/\xAF#%<;'=.##&&!&'#/\x9A$%<%%<;*=.##&&!&'#/5#;P/,$;*/#$+#)(#'#(\"'#&'#=.##&&!&'#/]$%<;\\=.##&&!&'#/H$%<;D=/##&'!&&#/3$$;;0#*;;&/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%<;\\=.##&&!&'#/\xB3#$;E.N &;F.H &;\\.B &%;P/8#%<;^=.##&&!&'#/#$+\")(\"'#&'#0T*;E.N &;F.H &;\\.B &%;P/8#%<;^=.##&&!&'#/#$+\")(\"'#&'#&/A$;P/8$%<;^=/##&'!&&#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            '%;%/E#%;\\/,#;K/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#.O &%%;%/,#;D/#$+")("\'#&\'#/2#;K/)$8":+""! )("\'#&\'#'
          ),
          peg$decode(
            '%%<;;=/##&\'!&&#/N#;+/E$%;\\/,#;K/#$+")("\'#&\'#/)$8#:*#"! )(#\'#("\'#&\'#.g &%%;+/,#;D/#$+")("\'#&\'#/J#%;K/1#;\\." &"/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#'
          ),
          peg$decode(
            "%;<.# &;4/G#%<;?=/##&'!&&#/2$;K/)$8#:*#\"\" )(#'#(\"'#&'#"
          ),
          peg$decode(
            '%%;<.# &;4/8#%<;?=.##&&!&\'#/#$+")("\'#&\'#/J#%;K/1#;\\." &"/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#'
          ),
          peg$decode(
            "%%<;0=.##&&!&'#/\xAA#%<;/=.##&&!&'#/\x95$%<;3=.##&&!&'#/\x80$%<;2=.##&&!&'#/k$;7/b$%<;?=.##&&!&'#/M$%<;K=.##&&!&'#/8$%<;\\=.##&&!&'#/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%;</,#;H/#$+\")(\"'#&'#.# &;7/Z#%<;?=/##&'!&&#/E$%;\\/,#;K/#$+\")(\"'#&'#/)$8#:*#\"\" )(#'#(\"'#&'#"
          ),
          peg$decode(
            '%%;</,#;H/#$+")("\'#&\'#.# &;7/h#%%<;?=.##&&!&\'#/C#;\\/:$;K/1$;\\." &"/#$+$)($\'#(#\'#("\'#&\'#/)$8":,""! )("\'#&\'#'
          ),
          peg$decode('%;=/,#;P/#$+")("\'#&\'#'),
          peg$decode(';4.# &;6'),
          peg$decode('%;N/,#;H/#$+")("\'#&\'#'),
          peg$decode(';5.# &;8'),
          peg$decode(
            "%%;P/c#%;H/J#%<;?=.##&&!&'#/5$;\\/,$;H/#$+$)($'#(#'#(\"'#&'#.# &;G/#$+\")(\"'#&'#/{#%;U/8#%<;P=/##&'!&&#/#$+\")(\"'#&'#.B &%;T/8#%<;U=/##&'!&&#/#$+\")(\"'#&'#.\" &\"/)$8\":*\"\"! )(\"'#&'#"
          ),
          peg$decode(
            ";$.~ &%;=/t#%<;?=/##&'!&&#/_$;\\/V$%<;>=/##&'!&&#/A$;H/8$%<;]=/##&'!&&#/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%<;>=/##&'!&&#/Z#%;P/,#;G/#$+\")(\"'#&'#.# &;6/8$%<;]=/##&'!&&#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode("%;A/8#%<;?=.##&&!&'#/#$+\")(\"'#&'#.# &;B"),
          peg$decode('%;5/,#;P/#$+")("\'#&\'#'),
          peg$decode('%;P/,#;H/#$+")("\'#&\'#'),
          peg$decode(
            "%;D/k#%<;K=.##&&!&'#/V$;E/M$%<;#=.##&&!&'#/8$%<;]=/##&'!&&#/#$+%)(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            '%$;P.# &;F0)*;P.# &;F&/Q#;\\." &"/C$;K." &"/5$;A/,$;^/#$+%)(%\'#($\'#(#\'#("\'#&\'#'
          ),
          peg$decode('%;D/:#;E/1$;C." &"/#$+#)(#\'#("\'#&\'#.# &;B'),
          peg$decode(
            "%;D/O#%<;K=.##&&!&'#/:$;E/1$;C.\" &\"/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode("%;P/A#%<;Q=/##&'!&&#/,$;C/#$+#)(#'#(\"'#&'#"),
          peg$decode(
            "%%<;@=.##&&!&'#/A#;P/8$%<;@=/##&'!&&#/#$+#)(#'#(\"'#&'#.U &%;Q.\" &\"/F#;P.\" &\"/8$%<;^=/##&'!&&#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode(
            ";\\.\u0152 &%;P.\" &\"/,#;F/#$+\")(\"'#&'#.\u0134 &%;O.\xFA &%%;Y/8#%<;Z=.##&&!&'#/#$+\")(\"'#&'#.N &%;X/D#%<;T.) &;R.# &;U=.##&&!&'#/#$+\")(\"'#&'#.\" &\"/\x9B#;V.s &%;[.H &;W.B &%;T/8#%<;U=.##&&!&'#/#$+\")(\"'#&'#/8#%<;R=.##&&!&'#/#$+\")(\"'#&'#.# &;S.\" &\"/7$;R.# &;U.\" &\"/#$+#)(#'#(\"'#&'#/M#%<;P=.##&&!&'#/8$%<;F=.##&&!&'#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode(";H.H &;G.B &%;K/8#%<;E=.##&&!&'#/#$+\")(\"'#&'#"),
          peg$decode("%;L.# &;M/8#%<;E=/##&'!&&#/#$+\")(\"'#&'#"),
          peg$decode(
            "%%4-\"\"5!7./A#;M/8$%<;J=.##&&!&'#/#$+#)(#'#(\"'#&'#.Q &%4/\"\"5!70/A#;L/8$%<;I=.##&&!&'#/#$+#)(#'#(\"'#&'#/8#%<;E=.##&&!&'#/#$+\")(\"'#&'#"
          ),
          peg$decode('%41""5!72/8#%<;E=.##&&!&\'#/#$+")("\'#&\'#'),
          peg$decode('43""5!74'),
          peg$decode('45""5!76'),
          peg$decode(
            '%47""5!78/W#%<%%<;K=.##&&!&\'#/,#;E/#$+")("\'#&\'#=.##&&!&\'#/#$+")("\'#&\'#'
          ),
          peg$decode('49""5!7:'),
          peg$decode('%4;""5!7</& 8!:=! )'),
          peg$decode(
            "%%<;D=/##&'!&&#/J#;P/A$;P/8$%<;P=.##&&!&'#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode('%;[/,#;Y/#$+")("\'#&\'#.6 &%;W/,#;X/#$+")("\'#&\'#'),
          peg$decode(';V.; &;W.5 &;X./ &;Y.) &;[.# &;Q'),
          peg$decode(';R./ &;S.) &;T.# &;U'),
          peg$decode('4>""5!7?'),
          peg$decode('4@""5!7A'),
          peg$decode('%4B""5!7C/8#%<;O=.##&&!&\'#/#$+")("\'#&\'#'),
          peg$decode('4D""5!7E'),
          peg$decode('4F""5!7G'),
          peg$decode('4H""5!7I'),
          peg$decode('4J""5!7K'),
          peg$decode('4L""5!7M'),
          peg$decode('4N""5!7O'),
          peg$decode('4P""5!7Q'),
          peg$decode('%4R""5!7S/8#%<;E=/##&\'!&&#/#$+")("\'#&\'#'),
          peg$decode(';^.N &%%<;E=.##&&!&\'#/,#;"/#$+")("\'#&\'#.) &4T""5!7U'),
          peg$decode(';_.4 &%<1""5!7V=.##&&!&\'#'),
          peg$decode('%$4W""5!7X/,#0)*4W""5!7X&&&#/\' 8!:Y!! )'),
          peg$decode('$4Z""5!7[/,#0)*4Z""5!7[&&&#'),
        ],
        peg$currPos = 0,
        peg$savedPos = 0,
        peg$posDetailsCache = [{ line: 1, column: 1 }],
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$resultsCache = {},
        peg$result

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleIndices)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          )
        }

        peg$startRuleIndex = peg$startRuleIndices[options.startRule]
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos)
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos)
      }

      function expected(description, location) {
        location =
          location !== void 0
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location
        )
      }

      function error(message, location) {
        location =
          location !== void 0
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildSimpleError(message, location)
      }

      function peg$literalExpectation(text, ignoreCase) {
        return { type: 'literal', text: text, ignoreCase: ignoreCase }
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: 'class',
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase,
        }
      }

      function peg$anyExpectation() {
        return { type: 'any' }
      }

      function peg$endExpectation() {
        return { type: 'end' }
      }

      function peg$otherExpectation(description) {
        return { type: 'other', description: description }
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
          p

        if (details) {
          return details
        } else {
          p = pos - 1
          while (!peg$posDetailsCache[p]) {
            p--
          }

          details = peg$posDetailsCache[p]
          details = {
            line: details.line,
            column: details.column,
          }

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++
              details.column = 1
            } else {
              details.column++
            }

            p++
          }

          peg$posDetailsCache[pos] = details
          return details
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails = peg$computePosDetails(endPos)

        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column,
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column,
          },
        }
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos
          peg$maxFailExpected = []
        }

        peg$maxFailExpected.push(expected)
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location)
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected, found),
          expected,
          found,
          location
        )
      }

      function peg$decode(s) {
        var bc = new Array(s.length),
          i

        for (i = 0; i < s.length; i++) {
          bc[i] = s.charCodeAt(i) - 32
        }

        return bc
      }

      function peg$parseRule(index) {
        var bc = peg$bytecode[index],
          ip = 0,
          ips = [],
          end = bc.length,
          ends = [],
          stack = [],
          params,
          i

        var key = peg$currPos * 65 + index,
          cached = peg$resultsCache[key]

        if (cached) {
          peg$currPos = cached.nextPos

          return cached.result
        }

        while (true) {
          while (ip < end) {
            switch (bc[ip]) {
              case 0:
                stack.push(peg$consts[bc[ip + 1]])
                ip += 2
                break

              case 1:
                stack.push(void 0)
                ip++
                break

              case 2:
                stack.push(null)
                ip++
                break

              case 3:
                stack.push(peg$FAILED)
                ip++
                break

              case 4:
                stack.push([])
                ip++
                break

              case 5:
                stack.push(peg$currPos)
                ip++
                break

              case 6:
                stack.pop()
                ip++
                break

              case 7:
                peg$currPos = stack.pop()
                ip++
                break

              case 8:
                stack.length -= bc[ip + 1]
                ip += 2
                break

              case 9:
                stack.splice(-2, 1)
                ip++
                break

              case 10:
                stack[stack.length - 2].push(stack.pop())
                ip++
                break

              case 11:
                stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]))
                ip += 2
                break

              case 12:
                stack.push(input.substring(stack.pop(), peg$currPos))
                ip++
                break

              case 13:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1]) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 14:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1] === peg$FAILED) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 15:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1] !== peg$FAILED) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 16:
                if (stack[stack.length - 1] !== peg$FAILED) {
                  ends.push(end)
                  ips.push(ip)

                  end = ip + 2 + bc[ip + 1]
                  ip += 2
                } else {
                  ip += 2 + bc[ip + 1]
                }

                break

              case 17:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (input.length > peg$currPos) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 18:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (
                  input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) ===
                  peg$consts[bc[ip + 1]]
                ) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 19:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (
                  input
                    .substr(peg$currPos, peg$consts[bc[ip + 1]].length)
                    .toLowerCase() === peg$consts[bc[ip + 1]]
                ) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 20:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 21:
                stack.push(input.substr(peg$currPos, bc[ip + 1]))
                peg$currPos += bc[ip + 1]
                ip += 2
                break

              case 22:
                stack.push(peg$consts[bc[ip + 1]])
                peg$currPos += peg$consts[bc[ip + 1]].length
                ip += 2
                break

              case 23:
                stack.push(peg$FAILED)
                if (peg$silentFails === 0) {
                  peg$fail(peg$consts[bc[ip + 1]])
                }
                ip += 2
                break

              case 24:
                peg$savedPos = stack[stack.length - 1 - bc[ip + 1]]
                ip += 2
                break

              case 25:
                peg$savedPos = peg$currPos
                ip++
                break

              case 26:
                params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
                for (i = 0; i < bc[ip + 3]; i++) {
                  params[i] = stack[stack.length - 1 - params[i]]
                }

                stack.splice(
                  stack.length - bc[ip + 2],
                  bc[ip + 2],
                  peg$consts[bc[ip + 1]].apply(null, params)
                )

                ip += 4 + bc[ip + 3]
                break

              case 27:
                stack.push(peg$parseRule(bc[ip + 1]))
                ip += 2
                break

              case 28:
                peg$silentFails++
                ip++
                break

              case 29:
                peg$silentFails--
                ip++
                break

              default:
                throw new Error('Invalid opcode: ' + bc[ip] + '.')
            }
          }

          if (ends.length > 0) {
            end = ends.pop()
            ip = ips.pop()
          } else {
            break
          }
        }

        peg$resultsCache[key] = { nextPos: peg$currPos, result: stack[0] }

        return stack[0]
      }

      function _join(a) {
        if (typeof a == 'string') return a
        else {
          var r = ''
          for (var v in a) {
            r += _join(a[v])
          }
          return r
        }
      }

      function _node_int(a) {
        if (typeof a == 'string') return a
        var r = []
        for (var v in a) {
          r.push(_node_int(a[v]))
        }
        return r
      }

      peg$result = peg$parseRule(peg$startRuleIndex)

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation())
        }

        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        )
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse,
    }
  })()

  const sortMultiDimensional = (a, b) => {
    if (!a.d) a.d = ''
    if (!b.d) b.d = ''
    return a.d.length < b.d.length ? -1 : a.d.length > b.d.length ? 1 : 0
  }
  
const ma_klesi_lo_valsi = (str) => {
  let j = ['', '']
  if (!window.xuzganalojudri || str.search(/[^aeiouyAEIOY]'/) > -1) return j
  try {
    j = cmaxes.parse(str.toLowerCase())
    j = JSON.stringify(j)
    j = j.split(/","|\],\[/).map((i) => i.replace(/[^,a-zA-Z']/g, ''))
    if (str.includes(' zei ')) return ['zei-lujvo', str]
  } catch (e) {}
  if (
    j.length > 2 &&
    j
      .filter((el, index) => index % 2 === 0)
      .toString()
      .match(/^cmavo(,cmavo)+$/)
  ) {
    return [
      'cmavo compound',
      j.filter((el, index) => index % 2 === 1).join(' '),
    ]
  }
  return j
}

function ma_ve_lujvo(a) {
  if (!window.xuzganalojudri) return
  if (a.includes(' zei ')) return ['@'].concat(a.split(' '))
  let t
  try {
    t = cmaxes.parse(a).toString().split(',')
  } catch (err) {
    return
  }
  if (t[0] !== 'lujvo' || t.length !== 2) return
  return t[1].split('-')
}

const rafsi = {}
for (const cmima in sorcu[bau]) {
  const c = sorcu[bau][cmima]
  let i = (c['r'] || []).length
  while (i--) {
    rafsi[c['r'][i]] = c
    rafsi[c['r'][i]]['w'] = cmima
  }
  if (
    c['t'] === 'gismu' ||
    c['t'] === 'experimental gismu' ||
    c['t'] === "fu'ivla"
  ) {
    rafsi[cmima] = c
    rafsi[cmima]['w'] = cmima
  }
}

function setca_lotcila(doc) {
  if (!doc.t || doc.t === '') {
    if (!window.muplis && window.xuzganalojudri) {
      doc.t = ma_klesi_lo_valsi(doc.w)[0]
    } else {
      doc.t = ''
    }
  }
  return doc
}

window.storecache = {}
for (const i in sorcu[bau]) {
  window.storecache[i] = `${i};${Object.keys(sorcu[bau][i])
    .map((n) => sorcu[bau][i][n])
    .join(';')
    .toLowerCase()}`
  window.storecache[i] += `;${window.storecache[i].replace(/h/g, "'")}`
}

function sisku(data, callback) {
  const query = data.query
  const seskari = data.seskari
  let decomposed = false
  if (query.length === 0) return
  let secupra_vreji = []
  const query_apos = query.replace(/[h‘]/g, "'").toLowerCase()
  const queryDecomposition = decompose(query_apos)
  const kij = []
  const ki = []
  const mapti_vreji = []

  function decompose(a) {
    return window.xuzganalojudri
      ? a
          .replace(/ zei /g, '_zei_')
          .split(' ')
          .map((b) => b.replace(/_zei_/g, ' zei '))
      : a.split(' ')
  }

  function julne_setca_lotcila(a) {
    return a.reduce((b, n) => {
      if (n) b.push(setca_lotcila(n))
      return b
    }, [])
  }

  function sohivalsi(queryDecomposition, e, lu) {
    let kd = []
    let o
    for (let s = 0; s < queryDecomposition.length; s++) {
      for (let c = queryDecomposition.length - 1; c >= s; c--) {
        o = queryDecomposition.slice(s, c + 1).join(' ')
        if (!e || (e === 1 && o !== lu)) {
          kd = shortget(o, kd)
        }
      }
    }
    return kd
  }

  function jmina_ro_cmima_be_lehivalsi(query_string, doc) {
    const luj = ma_ve_lujvo(query_string)
    if (!luj) return doc ? [doc] : []
    let kim = []
    if (luj[0] === '@') {
      luj.shift()
      kim = luj.slice().map((i) => ({
        w: i,
        d: { nasezvafahi: true },
      }))
      for (const def in sorcu[bau]) {
        for (let j = 0; j < luj.length; j++) {
          if (def === luj[j]) {
            kim[j] = sorcu[bau][def]
            kim[j]['w'] = def
          }
        }
      }
    } else {
      for (const ji in luj) {
        const rf = rafsi[luj[ji]]
        if (rf) {
          kim.push(rf)
        } else if (luj[ji].length > 2) {
          kim = kim.concat([
            {
              t: '',
              d: { nasezvafahi: true },
              w: luj[ji],
              r: [luj[ji]],
            },
          ])
        }
      }
    }
    const aw = julne_setca_lotcila(kim) // .filter(function(i){return !i.d.nasezvafahi});
    return [
      {
        t: aw.length > 0 ? 'lujvo' : ma_klesi_lo_valsi(query)[0],
        w: query,
        d: { nasezvafahi: true },
        rfs: aw,
      },
    ]
  }

  function sortthem(mapti_vreji, multi) {
    let ui = [[], [], [], [], [], [], [], [], [], []]
    for (let i = 0; i < mapti_vreji.length; i++) {
      const doc = setca_lotcila(mapti_vreji[i]) // todo: optimize for phrases
      if (doc) {
        if (doc.w === query || doc.w === query_apos) {
          doc.rfs = JSON.parse(
            JSON.stringify(julne_setca_lotcila(sohivalsi(decompose(doc.w))))
          ).filter(({ w }) => w !== doc.w)
          decomposed = true
          if (doc.rfs.length === 0) {
            doc.rfs = jmina_ro_cmima_be_lehivalsi(
              doc.w,
              doc
            )[0].rfs
          }
          ui[0].push(doc)
        } else if (doc.g && doc.g.search(`^${query}(;|$)`) === 0) {
          ui[1].push(doc)
        } else if (doc.r && doc.r.join(' ').search(`\\b${query}\\b`) >= 0) {
          ui[5].push(doc)
        } else if (doc.w.search(`(^| )(${query_apos}|${query})( |$)`) >= 0) {
          ui[2].push(doc)
        } else if (doc.s && doc.s === query) {
          ui[3].push(doc)
        } else if (doc.s && doc.s.indexOf(query) === 0) {
          ui[9].push(doc)
        } else if (
          (doc.g && doc.g.search(`\\b${query}\\b`) >= 0) ||
          doc.w.search(`\\b(${query_apos}|${query})`) >= 0 ||
          doc.w.search(`(${query_apos}|${query})\\b`) >= 0
        ) {
          ui[4].push(doc)
        } else if (doc.d && doc.d.toLowerCase().search(`^${query}\\b`) >= 0) {
          ui[8].push(doc)
        } else if (doc.d && doc.d.toLowerCase().search(`\\b${query}\\b`) >= 0) {
          ui[6].push(doc)
        } else {
          ui[7].push(doc)
        }
      }
    }
    // if (ui[0].length === 0 && !multi) {
    // secupra_vreji = jmina_ro_cmima_be_lehivalsi(query) || [];
    // }
    const sortArray = (ar) => {
      if (ar.length === 0) return ar
      let gismu = []
      let cmavo = []
      let drata = []
      for (let c = 0; c < ar.length; c++) {
        if (ar[c].t === 'gismu') {
          gismu.push(ar[c])
        } else if (ar[c].t === 'cmavo') {
          cmavo.push(ar[c])
        } else {
          drata.push(ar[c])
        }
      }
      gismu = gismu.sort(sortMultiDimensional)
      cmavo = cmavo.sort(sortMultiDimensional)
      drata = drata.sort(sortMultiDimensional)
      return seskari === 'catni'
        ? [gismu.concat(cmavo), drata]
        : gismu.concat(cmavo).concat(drata)
    }
    ui = ui.map((i) => sortArray(i))
    let firstMatches
    let secondMatches
    if (seskari === 'catni') {
      ui = ui.map((i) => {
        if (i.length !== 2) i = [[], []]
        return i
      })
      firstMatches = secupra_vreji.concat(ui[0][0], ui[1][0])
      secondMatches = ui[3][0].concat(
        ui[9][0],
        ui[5][0],
        ui[2][0],
        ui[4][0],
        ui[8][0],
        ui[6][0],
        ui[7][0],
        ui[0][1],
        ui[1][1],
        ui[3][1],
        ui[9][1],
        ui[5][1],
        ui[2][1],
        ui[4][1],
        ui[8][1],
        ui[6][1],
        ui[7][1]
      )
    } else {
      firstMatches = secupra_vreji.concat(ui[0], ui[1])
      secondMatches = ui[3].concat(
        ui[9],
        ui[5],
        ui[2],
        ui[4],
        ui[8],
        ui[6],
        ui[7]
      )
    }
    if (firstMatches && firstMatches.w === query_apos) {
      for (let a = 1; a < firstMatches.length; a++) {
        if (firstMatches[a].l && firstMatches[a].d === `{${query_apos}}`) {
          firstMatches.splice(a, 1)
          --a
        }
      }
    }
    return [firstMatches.concat(secondMatches), firstMatches, secondMatches]
  }

  function shortget(a, ki, shi) {
    const isdef = Object.keys(sorcu[bau]).reduce((b, n) => {
      if (
        n.toLowerCase() === a.toLowerCase() ||
        (sorcu[bau][n]['d'] &&
          sorcu[bau][n]['d'].toLowerCase() === `{${a.toLowerCase()}}`)
      ) {
        const c = sorcu[bau][n]
        c['w'] = n
        b.push(c)
      }
      return b
    }, [])

    if (isdef && isdef.length > 0) {
      ki = ki.concat(isdef)
    } else {
      if (!shi) {
        if (a.replace(/ zei /g, '-zei-').split(' ').length === 1) {
          let ye = ma_klesi_lo_valsi(a)
          if (ye[0] === 'cmavo compound' || ye[0] === 'zei-lujvo') {
            ye = ye[1].split(' ')
            for (const jj in ye) {
              ki = shortget(ye[jj], ki, 2)
            }
          } else if (ye[0] !== '') {
            ye = ye.filter((element, index, array) => index % 2 !== 0)
            for (const jj in ye) {
              ki = shortget(ye[jj].replace(/-/g, ''), ki, 2)
            }
          }
        } else {
          const luj = ma_ve_lujvo(a)
          if (((luj || [])[0] || '') === '@') {
            luj.shift()
            let kim = []
            kim = luj.slice()
            for (const def in sorcu[bau]) {
              for (let j = 0; j < luj.length; j++) {
                if (def === luj[j]) {
                  kim[j] = sorcu[bau][def]
                  kim[j]['w'] = def
                }
              }
            }
            ki.concat(kim)
          } else if (luj) {
            for (const ji in luj) {
              ki.push(rafsi[luj[ji]])
            }
          }
        }
      } else {
        let ff = jmina_ro_cmima_be_lehivalsi(a)
        ff = ff[0] && ff[0].rfs ? ff[0].rfs : undefined
        ki = ki.concat([
          { t: '', d: { nasezvafahi: true }, w: a, rfs: ff },
        ])
      }
    }
    return ki
  }

  function cnanosisku(mapti_vreji, multi) {
    for (const n in sorcu[bau]) {
      if (window.storecache[n].includes(query.toLowerCase())) {
        const c = sorcu[bau][n]
        c['w'] = n
        mapti_vreji.push(c)
      }
    }
    const allMatches = sortthem(mapti_vreji, multi)
    if (multi) return allMatches[0]
    if (allMatches[0].length === 0) {
      allMatches[0] = jmina_ro_cmima_be_lehivalsi(query) || []
    }
    if (allMatches[0].length === 0 || allMatches[0][0].w !== query_apos) {
      let ty = /^[A-Zh]+[0-9\*]+$/.test(query)
        ? []
        : julne_setca_lotcila(shortget(query_apos, []))
      if (window.muplis || !window.xuzganalojudri) {
        ty = ty.filter(({ d }) => !d || !d.nasezvafahi)
      }
      if (ty.length <= 1) return ty.concat(allMatches[0])
      return allMatches[1].concat(
        [
          {
            t: window.bangudecomp,
            ot: "vlaza'umei",
            w: query,
            rfs: ty,
          },
        ],
        allMatches[2]
      )
    }
    return allMatches[0]
  }

  if (query.indexOf('^') === 0 || query.slice(-1) === '$') {
    secupra_vreji = julne_setca_lotcila(
      sortthem(
        Object.keys(sorcu[bau])
          .reduce((b, n) => {
            if ((n.match(query.toLowerCase()) || []).length > 0) {
              const c = sorcu[bau][n]
              c['w'] = n
              b.push(c)
            }
            return b
          }, [])
          .splice(0, 200)
      )[0]
    )
  } else if (seskari === 'rimni') {
    secupra_vreji = siskurimni(query)
  } else if (!window.muplis && queryDecomposition.length > 1) {
    secupra_vreji = cnanosisku(mapti_vreji, true)
    if (!decomposed) {
      secupra_vreji.push({
        t: window.bangudecomp,
        ot: "vlaza'umei",
        w: query,
        rfs: julne_setca_lotcila(sohivalsi(queryDecomposition)),
      })
    }
    decomposed = false
  } else {
    secupra_vreji = cnanosisku(mapti_vreji)
  }
  callback(secupra_vreji)
}

function krulermorna(t) {
  return `.${t
    .replace(/\./g, '')
    .replace(/^/, '.')
    .replace(/h/g, "'")
    .toLowerCase()
    .replace(/([aeiouy\.])u([aeiouy])/g, '$1w$2')
    .replace(/([aeiouy\.])i([aeiouy])/g, '$1ɩ$2')
    .replace(/au/g, 'ḁ')
    .replace(/ai/g, 'ą')
    .replace(/ei/g, 'ę')
    .replace(/oi/g, 'ǫ')
    .replace(/\./g, '')}`
}

function siskurimni(query) {
  if (query.length === 0) return
  const rimni = [[], [], [], [], [], [], [], [], []]
  let query_apos
  let queryF
  let queryR
  function cupra_lo_porsi(a) {
    for (let i = 0; i < a.length; i++) {
      const doc = setca_lotcila(a[i]) // todo: optimize for phrases
      if (!doc) continue
      const docw = krulermorna(doc.w)
        .replace(/([aeiouḁąęǫy])/g, '$1-')
        .split('-')
        .slice(-3)
      if (queryR && docw[0].slice(-1) !== queryR[0].slice(-1)) continue
      const right = docw[1].slice(-1)
      const reversal =
        docw[1].slice(-3, -1) ===
        queryF[1].slice(-3, -1).split('').reverse().join('')
      const left = queryF[1].slice(-1)
      let sli = false
      if (
        (left === 'a' && right.search('[eao]') >= 0) ||
        (left === 'e' && right.search('[iea]') >= 0) ||
        (left === 'i' && right.search('[ie]') >= 0) ||
        (left === 'o' && right.search('[aou]') >= 0) ||
        (left === 'u' && right.search('[aou]') >= 0)
      ) {
        sli = true
      }
      if (krulermorna(doc.w) === query) {
        rimni[0].push(doc)
        continue
      } else if (docw[2] || '' === queryR[2] || '') {
        // if (queryR[2])
        if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0 &&
          left === right
        ) {
          rimni[1].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0 &&
          sli
        ) {
          rimni[2].push(doc)
        } else if (
          (docw[1].match(regexify(queryR[2] || '')) || []).length > 0 &&
          left === right
        ) {
          rimni[3].push(doc)
        } else if (
          (docw[1].match(regexify(queryR[2] || '')) || []).length > 0 &&
          sli
        ) {
          rimni[4].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          sli &&
          reversal
        ) {
          rimni[5].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0
        ) {
          rimni[6].push(doc)
        }
      } else if (
        queryR[1] &&
        (docw[0].match(queryR[0]) || []).length > 0 &&
        (docw[1].match(queryR[1]) || []).length > 0
      ) {
        rimni[7].push(doc)
      } else {
        rimni[8].push(doc)
      }
    }
    const sortArray = (ar) => {
      if (ar.length === 0) return []
      const gism = []
      const expgism = []
      const cmav = []
      const expcmav = []
      const drata = []
      for (let c = 0; c < ar.length; c++) {
        if (ar[c].t === 'gismu') {
          gism.push(ar[c])
        } else if (ar[c].t === 'experimental gismu') {
          expgism.push(ar[c])
        } else if (ar[c].t === 'cmavo') {
          cmav.push(ar[c])
        } else if (ar[c].t === 'experimental cmavo') {
          expcmav.push(ar[c])
        } else {
          drata.push(ar[c])
        }
      }
      return gism
        .sort(sortMultiDimensional)
        .concat(
          expgism.sort(sortMultiDimensional),
          cmav.sort(sortMultiDimensional),
          expcmav.sort(sortMultiDimensional),
          drata.sort(sortMultiDimensional)
        )
    }

    return rimni.reduce((list, x) => list.concat(sortArray(x)), [])
  }

  function regexify(t) {
    return t
      .replace(/[lmnr]/g, '[lmnr]')
      .replace(/[ɩw]/g, '[ɩw]')
      .replace(/[pb]/g, '[pb]')
      .replace(/[fv]/g, '[fv]')
      .replace(/[td]/g, '[td]')
      .replace(/[sz]/g, '[sz]')
      .replace(/[cj]/g, '[cj]')
      .replace(/[kg]/g, '[kg]')
      .replace(/x/g, '[xk]')
  }

  queryR = krulermorna(query)
    .replace(/([aeiouḁąęǫy])/g, '$1-')
    .split('-')
    .slice(-3)
  queryF = queryR.slice()
  if (queryR.length >= 2) {
    queryR[1] = queryR[1].replace(/[aeiouḁąęǫy]/, '[aeiouḁąęǫy]')
  }
  let r = /.*([aeiouḁąęǫy])/.exec(queryR[0])
  if (r === null) return []
  queryR[0] = r[1]
  if (queryR.length === 2) {
    r = Object.keys(sorcu[bau]).reduce((b, n) => {
      const queryRn = krulermorna(n)
        .replace(/([aeiouḁąęǫy])/g, '$1-')
        .split('-')
        .slice(-3)
      if (
        queryRn.length === 2 &&
        queryRn[0].split('').slice(-1)[0] === queryR[0].split('').slice(-1)[0]
      ) {
        let c = sorcu[bau][n]
        c['w'] = n
        c = setca_lotcila(c)
        if (c) b.push(c)
      }
      return b
    }, [])
  } else {
    query_apos = regexify((queryR || []).join(''))
    r = Object.keys(sorcu[bau]).reduce((b, n) => {
      if (
        (krulermorna(n).match(`${query_apos.toLowerCase()}$`) || []).length > 0
      ) {
        const c = sorcu[bau][n]
        c['w'] = n
        b.push(c)
      }
      return b
    }, [])
  }
  return cupra_lo_porsi(r)
}
