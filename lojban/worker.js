
    postMessage({kind: 'loading'});
    var cmaxes =
  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */
  (function () {
    'use strict'

    function peg$subclass(child, parent) {
      function ctor() {
        this.constructor = child
      }
      ctor.prototype = parent.prototype
      child.prototype = new ctor()
    }

    function peg$SyntaxError(message, expected, found, location) {
      this.message = message
      this.expected = expected
      this.found = found
      this.location = location
      this.name = 'SyntaxError'

      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, peg$SyntaxError)
      }
    }

    peg$subclass(peg$SyntaxError, Error)

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return '"' + literalEscape(expectation.text) + '"'
        },

        class: function (expectation) {
          var escapedParts = '',
            i

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts +=
              expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) +
                  '-' +
                  classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i])
          }

          return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'
        },

        any: function (expectation) {
          return 'any character'
        },

        end: function (expectation) {
          return 'end of input'
        },

        other: function (expectation) {
          return expectation.description
        },
      }

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase()
      }

      function literalEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function classEscape(s) {
        return s
          .replace(/\\/g, '\\\\')
          .replace(/\]/g, '\\]')
          .replace(/\^/g, '\\^')
          .replace(/-/g, '\\-')
          .replace(/\0/g, '\\0')
          .replace(/\t/g, '\\t')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/[\x00-\x0F]/g, function (ch) {
            return '\\x0' + hex(ch)
          })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
            return '\\x' + hex(ch)
          })
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
      }

      function describeExpected(expected) {
        var descriptions = new Array(expected.length),
          i,
          j

        for (i = 0; i < expected.length; i++) {
          descriptions[i] = describeExpectation(expected[i])
        }

        descriptions.sort()

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i]
              j++
            }
          }
          descriptions.length = j
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0]

          case 2:
            return descriptions[0] + ' or ' + descriptions[1]

          default:
            return (
              descriptions.slice(0, -1).join(', ') +
              ', or ' +
              descriptions[descriptions.length - 1]
            )
        }
      }

      function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : 'end of input'
      }

      return (
        'Expected ' +
        describeExpected(expected) +
        ' but ' +
        describeFound(found) +
        ' found.'
      )
    }

    function peg$parse(input, options) {
      options = options !== void 0 ? options : {}

      var peg$FAILED = {},
        peg$startRuleIndices = { text: 0 },
        peg$startRuleIndex = 0,
        peg$consts = [
          function (expr) {
            return _node_int(expr)
          },
          function (expr) {
            return expr
          },
          function (expr) {
            return ['cmavo', _join(expr)]
          },
          function (expr) {
            return ['gismu', _join(expr)]
          },
          function (expr) {
            return ['lujvo', _join(expr)]
          },
          function (expr) {
            return ["fu'ivla", _join(expr)]
          },
          function (expr) {
            return ['cmevla', _join(expr)]
          },
          function (expr) {
            return [_join(expr), '-']
          },
          function (expr) {
            return [_join(expr)]
          },
          function (expi, exp) {
            return [_join(expi), '-', _join(exp)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          function (exp, expr) {
            return [_join(exp), '-', _join(expr)]
          },
          /^[a]/,
          peg$classExpectation(['a'], false, false),
          /^[aeo]/,
          peg$classExpectation(['a', 'e', 'o'], false, false),
          /^[aeiou]/,
          peg$classExpectation(['a', 'e', 'i', 'o', 'u'], false, false),
          /^[i]/,
          peg$classExpectation(['i'], false, false),
          /^[u]/,
          peg$classExpectation(['u'], false, false),
          /^[y]/,
          peg$classExpectation(['y'], false, false),
          /^[i\u0269]/,
          peg$classExpectation(['i', '\u0269'], false, false),
          /^[uw]/,
          peg$classExpectation(['u', 'w'], false, false),
          function () {
            return ['u', '']
          },
          /^[l]/,
          peg$classExpectation(['l'], false, false),
          /^[m]/,
          peg$classExpectation(['m'], false, false),
          /^[n]/,
          peg$classExpectation(['n'], false, false),
          /^[r]/,
          peg$classExpectation(['r'], false, false),
          /^[pfbgvkx]/,
          peg$classExpectation(
            ['p', 'f', 'b', 'g', 'v', 'k', 'x'],
            false,
            false
          ),
          /^[d]/,
          peg$classExpectation(['d'], false, false),
          /^[jz]/,
          peg$classExpectation(['j', 'z'], false, false),
          /^[cs]/,
          peg$classExpectation(['c', 's'], false, false),
          /^[x]/,
          peg$classExpectation(['x'], false, false),
          /^[t]/,
          peg$classExpectation(['t'], false, false),
          /^[,']/,
          peg$classExpectation([',', "'"], false, false),
          /^[}]/,
          peg$classExpectation(['}'], false, false),
          peg$anyExpectation(),
          /^[^a-za-z,']/,
          peg$classExpectation([['a', 'z'], ['a', 'z'], ',', "'"], true, false),
          function (expr) {
            return ['drata', _join(expr)]
          },
          /^[^ ]/,
          peg$classExpectation([' '], true, false),
        ],
        peg$bytecode = [
          peg$decode("%$;!0#*;!&/' 8!: !! )"),
          peg$decode('%;"/\' 8!:!!! )'),
          peg$decode(
            ";_.\xEE &;#.\xE8 &%;'/' 8!:\"!! ).\xD6 &%;$/' 8!:#!! ).\xC4 &%%%<;$=.##&&!&'#/\x90#%<;&=.##&&!&'#/{$%<;'=.##&&!&'#/f$%<%;6/>#;\\/5$;K/,$;D/#$+$)($'#(#'#(\"'#&'#=.##&&!&'#/,$;(/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:$!! )./ &%;&/' 8!:%!! )"
          ),
          peg$decode(
            "%%%<;,=/##&'!&&#/N#$;@/&#0#*;@&&&#/8$%<;^=/##&'!&&#/#$+#)(#'#(\"'#&'#.# &;,/' 8!:&!! )"
          ),
          peg$decode(
            "%;</k#%<;?=/##&'!&&#/V$%<;>=/##&'!&&#/A$;H/8$%<;]=/##&'!&&#/#$+%)(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%;+/Q#;A/H$%<;?=/##&'!&&#/3$$;B0#*;B&/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode('%;%/,#;>/#$+")("\'#&\'#'),
          peg$decode(
            "%%<;#=.##&&!&'#/\u0172#%<%;4/X#%<;?=.##&&!&'#/C$;K/:$;\\.\" &\"/,$;(/#$+%)(%'#($'#(#'#(\"'#&'#.T &%;4/J#%<;?=/##&'!&&#/5$;K/,$;:/#$+$)($'#(#'#(\"'#&'#=.##&&!&'#/\xE7$%%<;\\=.##&&!&'#/\xA0#%<%;P/9#$;P/&#0#*;P&&&#/#$+\")(\"'#&'#=.##&&!&'#/k$;D/b$$%;E/,#;\\/#$+\")(\"'#&'#06*%;E/,#;\\/#$+\")(\"'#&'#&/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#.0 &$;K/&#0#*;K&&&#/8$%<;]=/##&'!&&#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%$%;3.c &;..] &;0.W &%%<;)=.##&&!&'#/A#;1/8$%<;)=.##&&!&'#/#$+#)(#'#(\"'#&'#/' 8!:'!! )0u*%;3.c &;..] &;0.W &%%<;)=.##&&!&'#/A#;1/8$%<;)=.##&&!&'#/#$+#)(#'#(\"'#&'#/' 8!:'!! )&/\x8E#%;&.# &;9/' 8!:(!! ).m &%;2.N &;-.H &;/.B &%;7/8#%<;?=/##&'!&&#/#$+\")(\"'#&'#/2#;:/)$8\":)\"\"! )(\"'#&'#/#$+\")(\"'#&'#"
          ),
          peg$decode(';&.) &;..# &;-'),
          peg$decode(
            "%$;10#*;1&/\xE2#;9.\xD3 &%;7/V#%<;?=/##&'!&&#/A$%<;K=.##&&!&'#/,$;:/#$+$)($'#(#'#(\"'#&'#.\x90 &;0.\x8A &;/.\x84 &%%;7/M#%<;?=/##&'!&&#/8$%<;K=.##&&!&'#/#$+#)(#'#(\"'#&'#.\" &\"/5#;N/,$;K/#$+#)(#'#(\"'#&'#.) &;3.# &;2/#$+\")(\"'#&'#"
          ),
          peg$decode(
            "%%<;*=.##&&!&'#/\xAF#%<;'=.##&&!&'#/\x9A$%<%%<;*=.##&&!&'#/5#;P/,$;*/#$+#)(#'#(\"'#&'#=.##&&!&'#/]$%<;\\=.##&&!&'#/H$%<;D=/##&'!&&#/3$$;;0#*;;&/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%<;\\=.##&&!&'#/\xB3#$;E.N &;F.H &;\\.B &%;P/8#%<;^=.##&&!&'#/#$+\")(\"'#&'#0T*;E.N &;F.H &;\\.B &%;P/8#%<;^=.##&&!&'#/#$+\")(\"'#&'#&/A$;P/8$%<;^=/##&'!&&#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            '%;%/E#%;\\/,#;K/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#.O &%%;%/,#;D/#$+")("\'#&\'#/2#;K/)$8":+""! )("\'#&\'#'
          ),
          peg$decode(
            '%%<;;=/##&\'!&&#/N#;+/E$%;\\/,#;K/#$+")("\'#&\'#/)$8#:*#"! )(#\'#("\'#&\'#.g &%%;+/,#;D/#$+")("\'#&\'#/J#%;K/1#;\\." &"/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#'
          ),
          peg$decode(
            "%;<.# &;4/G#%<;?=/##&'!&&#/2$;K/)$8#:*#\"\" )(#'#(\"'#&'#"
          ),
          peg$decode(
            '%%;<.# &;4/8#%<;?=.##&&!&\'#/#$+")("\'#&\'#/J#%;K/1#;\\." &"/#$+")("\'#&\'#/)$8":*""! )("\'#&\'#'
          ),
          peg$decode(
            "%%<;0=.##&&!&'#/\xAA#%<;/=.##&&!&'#/\x95$%<;3=.##&&!&'#/\x80$%<;2=.##&&!&'#/k$;7/b$%<;?=.##&&!&'#/M$%<;K=.##&&!&'#/8$%<;\\=.##&&!&'#/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%;</,#;H/#$+\")(\"'#&'#.# &;7/Z#%<;?=/##&'!&&#/E$%;\\/,#;K/#$+\")(\"'#&'#/)$8#:*#\"\" )(#'#(\"'#&'#"
          ),
          peg$decode(
            '%%;</,#;H/#$+")("\'#&\'#.# &;7/h#%%<;?=.##&&!&\'#/C#;\\/:$;K/1$;\\." &"/#$+$)($\'#(#\'#("\'#&\'#/)$8":,""! )("\'#&\'#'
          ),
          peg$decode('%;=/,#;P/#$+")("\'#&\'#'),
          peg$decode(';4.# &;6'),
          peg$decode('%;N/,#;H/#$+")("\'#&\'#'),
          peg$decode(';5.# &;8'),
          peg$decode(
            "%%;P/c#%;H/J#%<;?=.##&&!&'#/5$;\\/,$;H/#$+$)($'#(#'#(\"'#&'#.# &;G/#$+\")(\"'#&'#/{#%;U/8#%<;P=/##&'!&&#/#$+\")(\"'#&'#.B &%;T/8#%<;U=/##&'!&&#/#$+\")(\"'#&'#.\" &\"/)$8\":*\"\"! )(\"'#&'#"
          ),
          peg$decode(
            ";$.~ &%;=/t#%<;?=/##&'!&&#/_$;\\/V$%<;>=/##&'!&&#/A$;H/8$%<;]=/##&'!&&#/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            "%%<;>=/##&'!&&#/Z#%;P/,#;G/#$+\")(\"'#&'#.# &;6/8$%<;]=/##&'!&&#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode("%;A/8#%<;?=.##&&!&'#/#$+\")(\"'#&'#.# &;B"),
          peg$decode('%;5/,#;P/#$+")("\'#&\'#'),
          peg$decode('%;P/,#;H/#$+")("\'#&\'#'),
          peg$decode(
            "%;D/k#%<;K=.##&&!&'#/V$;E/M$%<;#=.##&&!&'#/8$%<;]=/##&'!&&#/#$+%)(%'#($'#(#'#(\"'#&'#"
          ),
          peg$decode(
            '%$;P.# &;F0)*;P.# &;F&/Q#;\\." &"/C$;K." &"/5$;A/,$;^/#$+%)(%\'#($\'#(#\'#("\'#&\'#'
          ),
          peg$decode('%;D/:#;E/1$;C." &"/#$+#)(#\'#("\'#&\'#.# &;B'),
          peg$decode(
            "%;D/O#%<;K=.##&&!&'#/:$;E/1$;C.\" &\"/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode("%;P/A#%<;Q=/##&'!&&#/,$;C/#$+#)(#'#(\"'#&'#"),
          peg$decode(
            "%%<;@=.##&&!&'#/A#;P/8$%<;@=/##&'!&&#/#$+#)(#'#(\"'#&'#.U &%;Q.\" &\"/F#;P.\" &\"/8$%<;^=/##&'!&&#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode(
            ";\\.\u0152 &%;P.\" &\"/,#;F/#$+\")(\"'#&'#.\u0134 &%;O.\xFA &%%;Y/8#%<;Z=.##&&!&'#/#$+\")(\"'#&'#.N &%;X/D#%<;T.) &;R.# &;U=.##&&!&'#/#$+\")(\"'#&'#.\" &\"/\x9B#;V.s &%;[.H &;W.B &%;T/8#%<;U=.##&&!&'#/#$+\")(\"'#&'#/8#%<;R=.##&&!&'#/#$+\")(\"'#&'#.# &;S.\" &\"/7$;R.# &;U.\" &\"/#$+#)(#'#(\"'#&'#/M#%<;P=.##&&!&'#/8$%<;F=.##&&!&'#/#$+#)(#'#(\"'#&'#"
          ),
          peg$decode(";H.H &;G.B &%;K/8#%<;E=.##&&!&'#/#$+\")(\"'#&'#"),
          peg$decode("%;L.# &;M/8#%<;E=/##&'!&&#/#$+\")(\"'#&'#"),
          peg$decode(
            "%%4-\"\"5!7./A#;M/8$%<;J=.##&&!&'#/#$+#)(#'#(\"'#&'#.Q &%4/\"\"5!70/A#;L/8$%<;I=.##&&!&'#/#$+#)(#'#(\"'#&'#/8#%<;E=.##&&!&'#/#$+\")(\"'#&'#"
          ),
          peg$decode('%41""5!72/8#%<;E=.##&&!&\'#/#$+")("\'#&\'#'),
          peg$decode('43""5!74'),
          peg$decode('45""5!76'),
          peg$decode(
            '%47""5!78/W#%<%%<;K=.##&&!&\'#/,#;E/#$+")("\'#&\'#=.##&&!&\'#/#$+")("\'#&\'#'
          ),
          peg$decode('49""5!7:'),
          peg$decode('%4;""5!7</& 8!:=! )'),
          peg$decode(
            "%%<;D=/##&'!&&#/J#;P/A$;P/8$%<;P=.##&&!&'#/#$+$)($'#(#'#(\"'#&'#"
          ),
          peg$decode('%;[/,#;Y/#$+")("\'#&\'#.6 &%;W/,#;X/#$+")("\'#&\'#'),
          peg$decode(';V.; &;W.5 &;X./ &;Y.) &;[.# &;Q'),
          peg$decode(';R./ &;S.) &;T.# &;U'),
          peg$decode('4>""5!7?'),
          peg$decode('4@""5!7A'),
          peg$decode('%4B""5!7C/8#%<;O=.##&&!&\'#/#$+")("\'#&\'#'),
          peg$decode('4D""5!7E'),
          peg$decode('4F""5!7G'),
          peg$decode('4H""5!7I'),
          peg$decode('4J""5!7K'),
          peg$decode('4L""5!7M'),
          peg$decode('4N""5!7O'),
          peg$decode('4P""5!7Q'),
          peg$decode('%4R""5!7S/8#%<;E=/##&\'!&&#/#$+")("\'#&\'#'),
          peg$decode(';^.N &%%<;E=.##&&!&\'#/,#;"/#$+")("\'#&\'#.) &4T""5!7U'),
          peg$decode(';_.4 &%<1""5!7V=.##&&!&\'#'),
          peg$decode('%$4W""5!7X/,#0)*4W""5!7X&&&#/\' 8!:Y!! )'),
          peg$decode('$4Z""5!7[/,#0)*4Z""5!7[&&&#'),
        ],
        peg$currPos = 0,
        peg$savedPos = 0,
        peg$posDetailsCache = [{ line: 1, column: 1 }],
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$resultsCache = {},
        peg$result

      if ('startRule' in options) {
        if (!(options.startRule in peg$startRuleIndices)) {
          throw new Error(
            'Can\'t start parsing from rule "' + options.startRule + '".'
          )
        }

        peg$startRuleIndex = peg$startRuleIndices[options.startRule]
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos)
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos)
      }

      function expected(description, location) {
        location =
          location !== void 0
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location
        )
      }

      function error(message, location) {
        location =
          location !== void 0
            ? location
            : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildSimpleError(message, location)
      }

      function peg$literalExpectation(text, ignoreCase) {
        return { type: 'literal', text: text, ignoreCase: ignoreCase }
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: 'class',
          parts: parts,
          inverted: inverted,
          ignoreCase: ignoreCase,
        }
      }

      function peg$anyExpectation() {
        return { type: 'any' }
      }

      function peg$endExpectation() {
        return { type: 'end' }
      }

      function peg$otherExpectation(description) {
        return { type: 'other', description: description }
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos],
          p

        if (details) {
          return details
        } else {
          p = pos - 1
          while (!peg$posDetailsCache[p]) {
            p--
          }

          details = peg$posDetailsCache[p]
          details = {
            line: details.line,
            column: details.column,
          }

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++
              details.column = 1
            } else {
              details.column++
            }

            p++
          }

          peg$posDetailsCache[pos] = details
          return details
        }
      }

      function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails = peg$computePosDetails(endPos)

        return {
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column,
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column,
          },
        }
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
          return
        }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos
          peg$maxFailExpected = []
        }

        peg$maxFailExpected.push(expected)
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location)
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected, found),
          expected,
          found,
          location
        )
      }

      function peg$decode(s) {
        var bc = new Array(s.length),
          i

        for (i = 0; i < s.length; i++) {
          bc[i] = s.charCodeAt(i) - 32
        }

        return bc
      }

      function peg$parseRule(index) {
        var bc = peg$bytecode[index],
          ip = 0,
          ips = [],
          end = bc.length,
          ends = [],
          stack = [],
          params,
          i

        var key = peg$currPos * 65 + index,
          cached = peg$resultsCache[key]

        if (cached) {
          peg$currPos = cached.nextPos

          return cached.result
        }

        while (true) {
          while (ip < end) {
            switch (bc[ip]) {
              case 0:
                stack.push(peg$consts[bc[ip + 1]])
                ip += 2
                break

              case 1:
                stack.push(void 0)
                ip++
                break

              case 2:
                stack.push(null)
                ip++
                break

              case 3:
                stack.push(peg$FAILED)
                ip++
                break

              case 4:
                stack.push([])
                ip++
                break

              case 5:
                stack.push(peg$currPos)
                ip++
                break

              case 6:
                stack.pop()
                ip++
                break

              case 7:
                peg$currPos = stack.pop()
                ip++
                break

              case 8:
                stack.length -= bc[ip + 1]
                ip += 2
                break

              case 9:
                stack.splice(-2, 1)
                ip++
                break

              case 10:
                stack[stack.length - 2].push(stack.pop())
                ip++
                break

              case 11:
                stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]))
                ip += 2
                break

              case 12:
                stack.push(input.substring(stack.pop(), peg$currPos))
                ip++
                break

              case 13:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1]) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 14:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1] === peg$FAILED) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 15:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (stack[stack.length - 1] !== peg$FAILED) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 16:
                if (stack[stack.length - 1] !== peg$FAILED) {
                  ends.push(end)
                  ips.push(ip)

                  end = ip + 2 + bc[ip + 1]
                  ip += 2
                } else {
                  ip += 2 + bc[ip + 1]
                }

                break

              case 17:
                ends.push(end)
                ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2])

                if (input.length > peg$currPos) {
                  end = ip + 3 + bc[ip + 1]
                  ip += 3
                } else {
                  end = ip + 3 + bc[ip + 1] + bc[ip + 2]
                  ip += 3 + bc[ip + 1]
                }

                break

              case 18:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (
                  input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) ===
                  peg$consts[bc[ip + 1]]
                ) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 19:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (
                  input
                    .substr(peg$currPos, peg$consts[bc[ip + 1]].length)
                    .toLowerCase() === peg$consts[bc[ip + 1]]
                ) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 20:
                ends.push(end)
                ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3])

                if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                  end = ip + 4 + bc[ip + 2]
                  ip += 4
                } else {
                  end = ip + 4 + bc[ip + 2] + bc[ip + 3]
                  ip += 4 + bc[ip + 2]
                }

                break

              case 21:
                stack.push(input.substr(peg$currPos, bc[ip + 1]))
                peg$currPos += bc[ip + 1]
                ip += 2
                break

              case 22:
                stack.push(peg$consts[bc[ip + 1]])
                peg$currPos += peg$consts[bc[ip + 1]].length
                ip += 2
                break

              case 23:
                stack.push(peg$FAILED)
                if (peg$silentFails === 0) {
                  peg$fail(peg$consts[bc[ip + 1]])
                }
                ip += 2
                break

              case 24:
                peg$savedPos = stack[stack.length - 1 - bc[ip + 1]]
                ip += 2
                break

              case 25:
                peg$savedPos = peg$currPos
                ip++
                break

              case 26:
                params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
                for (i = 0; i < bc[ip + 3]; i++) {
                  params[i] = stack[stack.length - 1 - params[i]]
                }

                stack.splice(
                  stack.length - bc[ip + 2],
                  bc[ip + 2],
                  peg$consts[bc[ip + 1]].apply(null, params)
                )

                ip += 4 + bc[ip + 3]
                break

              case 27:
                stack.push(peg$parseRule(bc[ip + 1]))
                ip += 2
                break

              case 28:
                peg$silentFails++
                ip++
                break

              case 29:
                peg$silentFails--
                ip++
                break

              default:
                throw new Error('Invalid opcode: ' + bc[ip] + '.')
            }
          }

          if (ends.length > 0) {
            end = ends.pop()
            ip = ips.pop()
          } else {
            break
          }
        }

        peg$resultsCache[key] = { nextPos: peg$currPos, result: stack[0] }

        return stack[0]
      }

      function _join(a) {
        if (typeof a == 'string') return a
        else {
          var r = ''
          for (var v in a) {
            r += _join(a[v])
          }
          return r
        }
      }

      function _node_int(a) {
        if (typeof a == 'string') return a
        var r = []
        for (var v in a) {
          r.push(_node_int(a[v]))
        }
        return r
      }

      peg$result = peg$parseRule(peg$startRuleIndex)

      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation())
        }

        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        )
      }
    }

    return {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse,
    }
  })()
    importScripts(
      'https://cdnjs.cloudflare.com/ajax/libs/dexie/2.0.4/dexie.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.10.1/polyfill.min.js'
    );
    const supportedLangs = {
  'en': { n: 'English', "p": "selsku_lanci_eng" },
  'muplis': { n: 'la muplis' },
  'en-cll': { n: 'The Book', "p": "cukta", noRafsi: true, searchPriority: true },
  'en-ll': { n: 'Learn Lojban', "p": "cukta", noRafsi: true, searchPriority: true },
  jbo: { n: 'lojbo', "p": "lanci_jbo", searchPriority: true },
  ru: { n: 'русский', "p": "selsku_lanci_rus" },
  eo: { n: 'esperanto', "p": "lanci_epo" },
  es: { n: 'español', "p": "selsku_lanci_spa" },
  'fr-facile': { n: 'français', "p": "selsku_lanci_fra" },
  ja: { n: '日本語', "p": "selsku_lanci_jpn" },
  zh: { n: '中文', "p": "selsku_lanci_zho" },
}


const db = new Dexie('sorcu1')
let leijufra = {
  xuzganalojudri: '', bangudecomp: ''
}


function initDb() {
  try {
    db.version(1).stores({
      valsi: '++id, bangu, w, d, n, t, *s, g, *r, *cache',
      langs_ready: '++id, bangu, timestamp',
      tejufra: '++id, &bangu, jufra',
    })
  } catch (error) {
  }
}
initDb()

async function cnanosisku({
  query_apos,
  query,
  bangu,
  versio,
  mapti_vreji,
  multi,
  seskari,
  secupra_vreji,
  queryDecomposition
}) {
  let rows
  if (versio === 'selmaho') {
    if (bangu === 'muplis') {
      rows = await db.valsi
        .where('s')
        .equals(query)
        .and((valsi) =>
          valsi.bangu === bangu
        )
        .distinct()
        .toArray();
    } else {
      rows = await db.valsi
        .where('s')
        .startsWith(query)
        .and((valsi) =>
          valsi.bangu === bangu &&
          typeof valsi.s === 'string' && new RegExp(`^${query}[0-9]*[a-z]*$`).test(valsi.s)
        )
        .distinct()
        .toArray();
    }
  } else if (seskari === 'fanva') {
    rows = (await db.valsi
      .where({ w: query_apos })
      .distinct()
      .toArray()).sort((a, b) => {
        if (a.bangu === bangu) { return -1 }
        if (supportedLangs[a.bangu].searchPriority) { return 0 }
        return 1
      });
  } else if (bangu === 'muplis' && queryDecomposition.length > 1) {
    const words = queryDecomposition.sort((a, b) => {
      if (a.lenth > b.length) return -1
      return 0
    })
    rows = (await db.valsi
      .where('cache')
      .equals(words[0])
      .and(jufra => {
        if (jufra.bangu === bangu && queryDecomposition.every(v => jufra.cache.includes(v))) return true;
        return false
      })
      .distinct()
      .toArray())
  } else {
    if (query_apos.length >= 2) {
      const reversed_query_apos = [...query_apos].reverse().join("")
      // const query_apos_length = query_apos.length
      await db.transaction('rw', db.valsi, async () => {
        const bothRows = await Promise.all([
          db.valsi
            .where('cache')
            .startsWith(query_apos)
            .and((valsi) => valsi.bangu.indexOf(bangu) === 0)
            .distinct()
            .toArray(),
          db.valsi
            .where('cache')
            .startsWith(reversed_query_apos)
            .and((valsi) => valsi.bangu.indexOf(bangu) === 0 && valsi.cache.filter(i => i.indexOf(query_apos) === 0).length === 0)
            .distinct()
            .toArray()
        ])
        rows = bothRows[0].concat(bothRows[1])
      })
    } else {
      rows = (await db.valsi
        .where('cache')
        .startsWith(query_apos)
        .and((valsi) => valsi.bangu.indexOf(bangu) === 0)
        .distinct()
        .toArray())
    }
  }
  rows = rows.map(el => {
    const { cache, ...rest } = el
    return rest;
  }).sort((a, b) => {
    if (supportedLangs[a.bangu].searchPriority) { return -1 }
    if (supportedLangs[b.bangu].searchPriority) { return 1 }
    return 0
  });
  mapti_vreji = mapti_vreji.slice().concat(
    rows.map((valsi) => {
      delete valsi.cache
      return valsi
    })
  )
  if (seskari === 'fanva' || bangu === 'muplis') {
    return { result: mapti_vreji, decomposed: false }
  }
  const { result, decomposed } = await sortthem({
    query_apos,
    query,
    bangu,
    mapti_vreji,
    multi,
    seskari,
    secupra_vreji,
  })

  const allMatches = result
  if (multi) return { result: allMatches[0], decomposed }
  if (allMatches[0].length === 0) {
    allMatches[0] = (await jmina_ro_cmima_be_lehivalsi({ query, bangu })) || []
  }
  if (allMatches[0].length === 0 || allMatches[0][0].w !== query_apos) {
    let ty = /^[A-Zh]+[0-9\*]+$/.test(query)
      ? []
      : julne_setca_lotcila(
        await shortget({ valsi: query_apos, secupra: [], bangu })
      )
    if (bangu === 'muplis' || !leijufra.xuzganalojudri) {
      ty = ty.filter(({ d }) => !d || !d.nasezvafahi)
    }
    if (ty.length <= 1) return { result: ty.concat(allMatches[0]), decomposed }
    const e = {
      result: allMatches[1].concat(
        [
          {
            t: leijufra.bangudecomp,
            ot: "vlaza'umei",
            w: query,
            rfs: ty,
          },
        ],
        allMatches[2]
      ),
      decomposed,
    }
    return e
  }

  return { result: allMatches[0], decomposed }
}

function sortMultiDimensional(a, b) {
  if (!a.d) a.d = ''
  if (!b.d) b.d = ''
  return a.d.length < b.d.length ? -1 : a.d.length > b.d.length ? 1 : 0
}

function cmaxesParse({tegerna},callback) {
  try {
    let parsed = cmaxes.parse(tegerna.toLowerCase())
    parsed = parsed.filter(el => el[0] !== 'drata')
    return callback(parsed)
  } catch (error) { }
  return callback([])
}

function reconcatenate(selsku) {
  try {
    let parsed = cmaxes.parse(selsku.toLowerCase())
    parsed = parsed.filter(el => el[0] !== 'drata')
    const reconcatenated = parsed.map(el => el[1]).join(' ')
    return { parsed, reconcatenated }
  } catch (error) { }
  return { parsed: [], reconcatenated: selsku }
}

function maklesi_levalsi(selsku) {
  let reconcatenated = selsku
  if (!leijufra.xuzganalojudri || selsku.search(/[^aeiouyAEIOY]'/) > -1) return ['', selsku]
  try {
    const { parsed: parsedString, reconcatenated } = reconcatenate(selsku)
    const oddEls = parsedString.filter((_, index) => index % 2 == 1)
    if (oddEls.length > 0 && oddEls.every(el => el[0] == 'zei')) return ['zei-lujvo', reconcatenated]
    if (parsedString.length == 1) return parsedString[0]
    if (parsedString.every(el => el[0] === 'cmavo')) return ['cmavo-compound', reconcatenated]
    if (parsedString.length > 1) return ['phrase', reconcatenated]
  } catch (e) { }
  return ['', reconcatenated]
}

function mevuhilevelujvo(tegerna) {
  if (!leijufra.xuzganalojudri) return
  if (tegerna.includes(' zei ')) return ['@'].concat(tegerna.split(' '))
  let text
  try {
    text = cmaxes.parse(tegerna).toString().split(',')
  } catch (err) {
    return
  }
  if (!['lujvo'].includes(text[0]) || text.length !== 2) return
  return text[1].split('-')
}

function setca_lotcila(doc) {
  if ([undefined, ''].includes(doc.t))
    doc.t = (doc.bangu !== 'muplis' && leijufra.xuzganalojudri) ? maklesi_levalsi(doc.w)[0] : ''
  return doc
}

function decompose(selsku) {
  return leijufra.xuzganalojudri
    ? reconcatenate(selsku).reconcatenated
      .replace(/ zei /g, '_zei_')
      .split(' ')
      .map((b) => b.replace(/_zei_/g, ' zei ').replace(/-/g, ''))
    : selsku.split(' ')
}

function julne_setca_lotcila(a) {
  return a.reduce((b, n) => {
    if (n) b.push(setca_lotcila(n))
    return b
  }, [])
}

async function sohivalsi(queryDecomposition, bangu) {
  let secupra = []
  for (let valsi_index = 0; valsi_index < queryDecomposition.length; valsi_index++) {
    for (let valsi2_index = queryDecomposition.length - 1; valsi2_index >= valsi_index; valsi2_index--) {
      const o = queryDecomposition.slice(valsi_index, valsi2_index + 1).join(' ')
      secupra = await shortget({ valsi: o, secupra, bangu })
    }
  }
  return secupra
}

async function jmina_ro_cmima_be_lehivalsi({ query, def, bangu }) {
  let vuhi_le_ve_lujvo = mevuhilevelujvo(query)
  if (!vuhi_le_ve_lujvo) return def ? [def] : []
  let vuhi_le_valsi = []
  if (vuhi_le_ve_lujvo[0] === '@') {
    vuhi_le_valsi = vuhi_le_ve_lujvo.slice(1).map((i) => ({
      w: i,
      d: { nasezvafahi: true },
    }))
    for (let j = 0; j < vuhi_le_valsi.length; j++) {
      const le_valsi = vuhi_le_valsi[j].w
      const le_se_skicu_veljvo = (
        await db.valsi.where({ w: le_valsi, bangu }).toArray()
      )[0]
      if (le_se_skicu_veljvo) {
        vuhi_le_valsi[j] = le_se_skicu_veljvo
        vuhi_le_valsi[j]['w'] = le_valsi
      }
    }
  } else {
    for (const ji in vuhi_le_ve_lujvo) {
      const rf = (
        await db.valsi.where({ r: vuhi_le_ve_lujvo[ji], bangu }).toArray()
      )[0]
      if (rf) {
        vuhi_le_valsi.push(rf)
      } else if (vuhi_le_ve_lujvo[ji].length > 2) {
        vuhi_le_valsi = vuhi_le_valsi.concat([
          {
            t: '',
            d: { nasezvafahi: true },
            w: vuhi_le_ve_lujvo[ji],
            r: [vuhi_le_ve_lujvo[ji]],
          },
        ])
      }
    }
  }
  const aw = julne_setca_lotcila(vuhi_le_valsi) // .filter(function(i){return !i.d.nasezvafahi});
  return [
    {
      t: aw.length > 0 ? 'lujvo' : maklesi_levalsi(query)[0],
      w: query,
      d: { nasezvafahi: true },
      rfs: aw,
    },
  ]
}

async function shortget({ valsi, secupra, nasisku_filohipagbu, bangu }) {
  const hasDefinitions = await db.valsi
    .where('w')
    .equalsIgnoreCase(valsi.toLowerCase())
    .or('d')
    .equalsIgnoreCase(valsi.toLowerCase())
    .and((valsi) => valsi.bangu === bangu)
    .toArray()
  if (hasDefinitions && hasDefinitions.length > 0)
    return secupra.concat(hasDefinitions)
  if (!nasisku_filohipagbu) {
    if (valsi.replace(/ zei /g, '-zei-').split(' ').length === 1) {
      let ye = maklesi_levalsi(valsi)
      if (ye[0] === 'cmavo-compound' || ye[0] === 'zei-lujvo') {
        ye = ye[1].split(' ')
        for (const jj in ye) {
          secupra = await shortget({
            valsi: ye[jj],
            secupra,
            nasisku_filohipagbu: true,
            bangu,
          })
        }
      } else if (ye[0] !== '') {
        ye = ye.filter((_, index, __) => index % 2 !== 0)
        for (const _ in ye) {
          secupra = await shortget({
            valsi: ye[_].replace(/-/g, ''),
            secupra,
            nasisku_filohipagbu: true,
            bangu,
          })
        }
      }
    } else {
      let vuhilevelujvo = mevuhilevelujvo(valsi)
      if ((vuhilevelujvo || [])[0] === '@') {
        vuhilevelujvo = vuhilevelujvo.slice(1)

        for (let j = 0; j < vuhilevelujvo.length; j++) {
          const le_valsi = vuhilevelujvo[j]
          const le_se_skicu_valsi = (
            await db.valsi.where({ w: le_valsi, bangu }).toArray()
          )[0]
          if (le_se_skicu_valsi) {
            vuhilevelujvo[j] = le_se_skicu_valsi
            vuhilevelujvo[j]['w'] = le_valsi
          }
        }
        secupra.concat(vuhi_le_valsi)
      } else if (vuhilevelujvo) {
        for (const r of vuhilevelujvo) {
          const foundRafsi = (await db.valsi({ r, bangu }).toArray())[0]
          if (foundRafsi) secupra.push(foundRafsi)
        }
      }
    }
  } else {
    let ff = await jmina_ro_cmima_be_lehivalsi({ query: valsi, bangu })
    ff = ff[0] && ff[0].rfs ? ff[0].rfs : undefined
    secupra = secupra.concat([
      { t: '', d: { nasezvafahi: true }, w: valsi, rfs: ff },
    ])
  }
  return secupra
}

function isCoreWord(def) {
  return ['gismu', 'cmavo'].includes(def.t)
}

function defaultPriorityGroups() {
  return {
    wordFullMatch: [],
    wordFullMatchAdditional: [],
    glossMatch: [],
    rafsiMatch: [],
    wordSemiMatch: [],
    selmahoFullMatch: [],
    selmahoSemiMatch: [],
    oneOfSelmahosFullMatch: [],
    oneOfSelmahosSemiMatch: [],
    glossSemiMatch: [],
    defGoodMatch: [],
    defInsideMatch: [],
    otherMatch: []
  }
}

async function sortthem({
  mapti_vreji,
  multi,
  query,
  bangu,
  query_apos,
  seskari,
  secupra_vreji,
}) {
  let decomposed = false
  let searchPriorityGroups = defaultPriorityGroups()
  for (let i = 0; i < mapti_vreji.length; i++) {
    const def = setca_lotcila(mapti_vreji[i]) // todo: optimize for phrases
    if (def) {
      if (def.w === query || def.w === query_apos) {
        if (!supportedLangs[def.bangu].noRafsi) {
          def.rfs = JSON.parse(
            JSON.stringify(
              julne_setca_lotcila(await sohivalsi(decompose(def.w), bangu))
            )
          ).filter(({ w }) => w !== def.w)
          decomposed = true
          if (def.rfs.length === 0) {
            def.rfs = (
              await jmina_ro_cmima_be_lehivalsi({ query: def.w, def: def, bangu })
            )[0].rfs
          }
        }
        if (def.bangu == bangu) searchPriorityGroups.wordFullMatch.push(def)
        else searchPriorityGroups.wordFullMatchAdditional.push(def)
      } else if (def.g && def.g.search(`^${query}(;|$)`) === 0) {
        searchPriorityGroups.glossMatch.push(def)
      } else if (def.r && def.r.join(' ').search(`\\b${query}\\b`) >= 0) {
        searchPriorityGroups.rafsiMatch.push(def)
      } else if (def.w.search(`(^| )(${query_apos}|${query})( |$)`) >= 0) {
        searchPriorityGroups.wordSemiMatch.push(def)
      } else if (def.s && typeof def.s === 'string' && def.s === query) {
        searchPriorityGroups.selmahoFullMatch.push(def)
      } else if (def.s && typeof def.s === 'string' && def.s.indexOf(query) === 0) {
        searchPriorityGroups.selmahoSemiMatch.push(def)
      } else if (def.s && Array.isArray(def.s) && def.s.includes(query)) {
        searchPriorityGroups.oneOfSelmahosFullMatch.push(def)
      } else if (def.s && Array.isArray(def.s) && def.s.filter(i => i.indexOf(query) === 0).length > 0) {
        searchPriorityGroups.oneOfSelmahosSemiMatch.push(def)
      } else if (
        (def.g && def.g.search(`\\b${query}\\b`) >= 0) ||
        def.w.search(`\\b(${query_apos}|${query})`) >= 0 ||
        def.w.search(`(${query_apos}|${query})\\b`) >= 0
      ) {
        searchPriorityGroups.glossSemiMatch.push(def)
      } else if (def.d && typeof def.d === 'string') {
        if (def.d.toLowerCase().search(`^${query}\\b`) >= 0) {
          searchPriorityGroups.defGoodMatch.push(def)
        } else if (def.d.toLowerCase().search(`\\b${query}\\b`) >= 0) {
          searchPriorityGroups.defInsideMatch.push(def)
        }
        else {
          searchPriorityGroups.otherMatch.push(def)
        }
      } else {
        searchPriorityGroups.otherMatch.push(def)
      }
    }
  }
  // if (ui[0].length === 0 && !multi) {
  // secupra_vreji = jmina_ro_cmima_be_lehivalsi(query) || [];
  // }

  let firstMatches
  let secondMatches
  if (seskari === 'catni') {
    const searchPriorityGroups_unofficial_words = defaultPriorityGroups()
    const searchPriorityGroups_official_words = defaultPriorityGroups()
    Object.keys(searchPriorityGroups).forEach(group => {
      searchPriorityGroups[group].forEach(def => {
        if (isCoreWord(def)) searchPriorityGroups_official_words[group].push(def)
        else searchPriorityGroups_unofficial_words[group].push(def)
      })
    })
    firstMatches = secupra_vreji.concat(searchPriorityGroups.wordFullMatch, searchPriorityGroups.wordFullMatchAdditional)
    secondMatches = [].concat(
      searchPriorityGroups_official_words.glossMatch,
      searchPriorityGroups_unofficial_words.glossMatch,
      searchPriorityGroups_official_words.selmahoFullMatch,
      searchPriorityGroups_unofficial_words.selmahoFullMatch,
      searchPriorityGroups.oneOfSelmahosFullMatch,
      searchPriorityGroups.rafsiMatch,
      searchPriorityGroups_official_words.wordSemiMatch,
      searchPriorityGroups_unofficial_words.wordSemiMatch,
      searchPriorityGroups_official_words.glossSemiMatch,
      searchPriorityGroups_unofficial_words.glossSemiMatch,
      searchPriorityGroups_official_words.defGoodMatch,
      searchPriorityGroups_unofficial_words.defGoodMatch,
      searchPriorityGroups_official_words.defInsideMatch,
      searchPriorityGroups_unofficial_words.defInsideMatch,
      searchPriorityGroups_official_words.otherMatch,
      searchPriorityGroups_unofficial_words.otherMatch,
    )
  } else if (seskari === 'cnano') {
    firstMatches = secupra_vreji.concat(searchPriorityGroups.wordFullMatch, searchPriorityGroups.wordFullMatchAdditional, searchPriorityGroups.glossMatch)
    secondMatches = [].concat(
      searchPriorityGroups.selmahoFullMatch,
      searchPriorityGroups.oneOfSelmahosFullMatch,
      searchPriorityGroups.rafsiMatch,
      searchPriorityGroups.wordSemiMatch,
      searchPriorityGroups.glossSemiMatch,
      searchPriorityGroups.defGoodMatch,
      searchPriorityGroups.defInsideMatch,
      searchPriorityGroups.otherMatch,
    )
  } else {
    firstMatches = secupra_vreji.concat(searchPriorityGroups.wordFullMatch, searchPriorityGroups.wordFullMatchAdditional, searchPriorityGroups.glossMatch)
    secondMatches = [].concat(
      searchPriorityGroups.selmahoFullMatch,
      searchPriorityGroups.oneOfSelmahosFullMatch,
      searchPriorityGroups.rafsiMatch,
      searchPriorityGroups.wordSemiMatch,
      searchPriorityGroups.glossSemiMatch,
      searchPriorityGroups.defGoodMatch,
      searchPriorityGroups.defInsideMatch,
      searchPriorityGroups.otherMatch,
    )
  }
  // if (firstMatches && firstMatches.w === query_apos) {
  //   for (let a = 1; a < firstMatches.length; a++) {
  //     if (firstMatches[a].l && firstMatches[a].d === `{${query_apos}}`) {
  //       firstMatches.splice(a, 1)
  //       --a
  //     }
  //   }
  // }
  return {
    result: [firstMatches.concat(secondMatches), firstMatches, secondMatches],
    decomposed,
  }
}

async function sisku(searching, callback) {
  const { query, seskari, bangu, versio, leijufra: leijufra_incoming, loadingState } = searching
  if (loadingState.loading) await db.open()

  if (!leijufra.bangu) {
    const tef1 = (await db.tejufra.where({ bangu: bangu.toString() }).toArray())[0] || {}
    if (tef1 && tef1.jufra) Object.keys(tef1.jufra.window || {}).forEach((key) => {
      const subKey = key.replace('window.', '')
      leijufra[subKey] = tef1.jufra.window[key]
    })
  }
  leijufra = { ...leijufra, ...leijufra_incoming }
  if (query.length === 0) return
  let secupra_vreji = []
  const query_apos = query.replace(/[h‘]/g, "'").toLowerCase()
  const queryDecomposition = decompose(query_apos)

  if (query.indexOf('^') === 0 || query.slice(-1) === '$') {
    const first1000 = (
      await db.valsi
        .where('bangu')
        .equals(bangu)
        .filter((valsi) => valsi.w.match(query.toLowerCase()))
        .distinct()
        .toArray()
    ).slice(0, 1000)
    secupra_vreji = julne_setca_lotcila(
      (
        await sortthem({
          query_apos,
          query,
          bangu,
          mapti_vreji: first1000,
          multi: false,
          seskari,
          secupra_vreji: [],
        })
      ).result[0]
    )
  } else if (seskari === 'rimni') {
    secupra_vreji = await siskurimni({ query, bangu })
  } else if (bangu !== 'muplis' && queryDecomposition.length > 1) {
    const { result, decomposed } = await cnanosisku({
      mapti_vreji: [],
      multi: true,
      query,
      bangu,
      query_apos,
      seskari,
      secupra_vreji,
    })
    secupra_vreji = result
    if (!decomposed) {
      secupra_vreji.push({
        t: 'bangudecomp',
        ot: "vlaza'umei",
        w: query,
        rfs: julne_setca_lotcila(await sohivalsi(queryDecomposition, bangu)),
      })
    }
  } else {
    const { result } = await cnanosisku({
      mapti_vreji: [],
      multi: false,
      query,
      bangu,
      versio,
      query_apos,
      seskari,
      secupra_vreji,
      queryDecomposition
    })
    secupra_vreji = result
  }
  callback({ results: secupra_vreji })
}

function krulermorna(t) {
  return `.${t
    .replace(/\./g, '')
    .replace(/^/, '.')
    .replace(/h/g, "'")
    .toLowerCase()
    .replace(/([aeiouy\.])u([aeiouy])/g, '$1w$2')
    .replace(/([aeiouy\.])i([aeiouy])/g, '$1ɩ$2')
    .replace(/au/g, 'ḁ')
    .replace(/ai/g, 'ą')
    .replace(/ei/g, 'ę')
    .replace(/oi/g, 'ǫ')
    .replace(/\./g, '')}`
}

async function siskurimni({ query, bangu }) {
  if (query.length === 0) return
  const rimni = [[], [], [], [], [], [], [], [], []]
  let query_apos
  let queryF
  let queryR
  function cupra_lo_porsi(a) {
    for (let i = 0; i < a.length; i++) {
      const doc = setca_lotcila(a[i]) // todo: optimize for phrases
      if (!doc) continue
      const docw = krulermorna(doc.w)
        .replace(/([aeiouḁąęǫy])/g, '$1-')
        .split('-')
        .slice(-3)
      if (queryR && docw[0].slice(-1) !== queryR[0].slice(-1)) continue
      const right = docw[1].slice(-1)
      const reversal =
        docw[1].slice(-3, -1) ===
        queryF[1].slice(-3, -1).split('').reverse().join('')
      const left = queryF[1].slice(-1)
      let sli = false
      if (
        (left === 'a' && right.search('[eao]') >= 0) ||
        (left === 'e' && right.search('[iea]') >= 0) ||
        (left === 'i' && right.search('[ie]') >= 0) ||
        (left === 'o' && right.search('[aou]') >= 0) ||
        (left === 'u' && right.search('[aou]') >= 0)
      ) {
        sli = true
      }
      if (krulermorna(doc.w) === query) {
        rimni[0].push(doc)
        continue
      } else if (docw[2] || '' === queryR[2] || '') {
        // if (queryR[2])
        if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0 &&
          left === right
        ) {
          rimni[1].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0 &&
          sli
        ) {
          rimni[2].push(doc)
        } else if (
          (docw[1].match(regexify(queryR[2] || '')) || []).length > 0 &&
          left === right
        ) {
          rimni[3].push(doc)
        } else if (
          (docw[1].match(regexify(queryR[2] || '')) || []).length > 0 &&
          sli
        ) {
          rimni[4].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          sli &&
          reversal
        ) {
          rimni[5].push(doc)
        } else if (
          (docw[0].match(queryR[0]) || []).length > 0 &&
          (docw[1].match(queryR[1]) || []).length > 0
        ) {
          rimni[6].push(doc)
        }
      } else if (
        queryR[1] &&
        (docw[0].match(queryR[0]) || []).length > 0 &&
        (docw[1].match(queryR[1]) || []).length > 0
      ) {
        rimni[7].push(doc)
      } else {
        rimni[8].push(doc)
      }
    }
    const sortArray = ({ ar }) => {
      if (ar.length === 0) return []
      const gism = []
      const expgism = []
      const cmav = []
      const expcmav = []
      const drata = []
      for (let c = 0; c < ar.length; c++) {
        if (ar[c].t === 'gismu') {
          gism.push(ar[c])
        } else if (ar[c].t === 'experimental gismu') {
          expgism.push(ar[c])
        } else if (ar[c].t === 'cmavo') {
          cmav.push(ar[c])
        } else if (ar[c].t === 'experimental cmavo') {
          expcmav.push(ar[c])
        } else {
          drata.push(ar[c])
        }
      }
      return gism
        .sort(sortMultiDimensional)
        .concat(
          expgism.sort(sortMultiDimensional),
          cmav.sort(sortMultiDimensional),
          expcmav.sort(sortMultiDimensional),
          drata.sort(sortMultiDimensional)
        )
    }

    return rimni.reduce((list, x) => list.concat(sortArray({ ar: x })), [])
  }

  function regexify(t) {
    return t
      .replace(/[lmnr]/g, '[lmnr]')
      .replace(/[ɩw]/g, '[ɩw]')
      .replace(/[pb]/g, '[pb]')
      .replace(/[fv]/g, '[fv]')
      .replace(/[td]/g, '[td]')
      .replace(/[sz]/g, '[sz]')
      .replace(/[cj]/g, '[cj]')
      .replace(/[kg]/g, '[kg]')
      .replace(/x/g, '[xk]')
  }

  queryR = krulermorna(query)
    .replace(/([aeiouḁąęǫy])/g, '$1-')
    .split('-')
    .slice(-3)
  queryF = queryR.slice()
  if (queryR.length >= 2) {
    queryR[1] = queryR[1].replace(/[aeiouḁąęǫy]/, '[aeiouḁąęǫy]')
  }
  let r = /.*([aeiouḁąęǫy])/.exec(queryR[0])
  if (r === null) return []
  queryR[0] = r[1]
  if (queryR.length === 2) {
    r =
      (await db.valsi
        .where({ bangu })
        .and((valsi) => {
          const queryRn = krulermorna(valsi.w)
            .replace(/([aeiouḁąęǫy])/g, '$1-')
            .split('-')
            .slice(-3)
          if (
            queryRn.length === 2 &&
            queryRn[0].split('').slice(-1)[0] ===
            queryR[0].split('').slice(-1)[0] &&
            setca_lotcila(valsi)
          )
            return true
          return false
        })
        .toArray()) || []
  } else {
    query_apos = regexify((queryR || []).join(''))
    r = await db.valsi
      .where({ bangu })
      .and((valsi) => {
        if (krulermorna(valsi.w).match(`${query_apos.toLowerCase()}$`))
          return true
        return false
      })
      .toArray()
  }
  return cupra_lo_porsi(r)
}

    postMessage({kind: 'ready'});
    self.onmessage = function(ev) {
      if (ev.data.kind == 'newSearch') {
        sisku(ev.data, function(res) {
          postMessage({
            kind: 'searchResults',
            results: res.results,
            req: {
              bangu: ev.data.bangu,
              seskari: ev.data.seskari,
              versio: ev.data.versio,
              query: ev.data.query         
            }
          })
        })
      } else if (ev.data.kind == 'parse') {
        cmaxesParse({tegerna: ev.data.tegerna}, function(res){
          postMessage({
            kind: 'parse',
            results: res,
            req: ev.data,
          })
        })
      }
    }